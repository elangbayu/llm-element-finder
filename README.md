# Selenium Web Automation with AI-Powered Element Search ü§ñüîé

Web automation that supercharged with an AI-powered feature for automatic element searching. This nifty feature uses special algorithms to find web elements more efficiently, cutting down on manual work and boosting test reliability.

## Key Features
- ü§ñ **AI-Powered Element Search**: Let AI do the heavy lifting in locating web elements!
- üìê **Page Object Model Design Pattern**: Keep your test architecture neat and scalable.
- üõ†Ô∏è **Centralized WebDriver Configuration**: Easy setup and management of WebDriver instances. 
- üí™ **Robust Error Handling**: Tests that can handle surprises! 
- üìù **Comprehensive Logging**: Detailed logs for smooth debugging and analysis. 

## Prerequisites
- Java 21 or higher
- Chrome Browser
- LLM Provider API key. ‚ö†Ô∏è *Only choose model that support structured output*.
- Environment variables:
  - `LLM_PROVIDER_API_KEY`: API Key to your LLM Provider
  - `LLM_MODEL`: Model to use as element finder
  - `LLM_BASE_API`: Base URL to call the API Key

## How It Works

This project incorporates a multi-layered approach to element identification, leveraging AI to enhance reliability and reduce reliance on brittle static selectors.

**`click()` method in `BasePage.java`**: This method serves as the primary way to interact with web elements. It is overloaded to provide multiple fallback mechanisms for locating and clicking on an element. The method first attempts to load a CSS selector from a `.properties` file (`elementSelectors.properties`). This acts as a cache of previously identified selectors, providing the fastest possible route for clicking the element. If a cached selector is unavailable or fails, the method falls back to a manually written `defaultSelector`. Should both the cache and the default approach fail to locate the element (e.g., due to changes in the DOM), the AI-powered search is triggered. This search calls `AiFallback.getElementFromAi()` with a prompt describing the desired element, uses an LLM to generate a new CSS selector, highlights the element with a red border, then caches the successful selector for future use.

**`AiFallback.java`**: This class is dedicated to AI-driven element discovery. Its `getElementFromAi()` method retrieves a processed version of the DOM to keep the context concise, then constructs a request to the LLM provider using a pre-defined model. The system message instructs the LLM to return a valid JSON containing the CSS selector, while the user message passes the prompt and reduced DOM. The response is parsed to extract the CSS selector. Afterward, the element is briefly highlighted with a red border to verify correctness. The `domProcessor()` method inside this class handles extracting a reduced portion of the DOM, focusing on relevant nodes. The `highlightElement()` method visually emphasizes the located element for a short time.

**`.properties` file (`elementSelectors.properties`)**: This file functions as a persistent cache for selectors generated by the AI. Each entry is a key-value pair, where the key is a unique identifier (used in the `click()` method) and the value is the CSS selector produced by the AI. The `BasePage` class manages reading and writing to this file, allowing tests to reuse selectors across multiple runs without re-invoking the AI.

## Project Structure
- `src/main/java/com/elangsegara/webautomation/config/`: WebDriver configuration
- `src/main/java/com/elangsegara/webautomation/core/`: Base page and core utilities
- `src/main/java/com/elangsegara/webautomation/pages/`: Page Object Model classes
- `src/test/java/`: Test cases

## Running Tests
```bash
./gradlew test
